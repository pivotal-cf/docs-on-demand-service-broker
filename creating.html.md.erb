---
title: Creating the Service Author Deliverables
owner: London Services Enablement
---

##<a id="what-is-required-of-the-service-authors"></a>Service Author Requirements
The following deliverables are required from the service authors:

- Service release(s)
- BOSH release(s) to be deployed by the manifest that is generated by the Service Adapter
- Service Adapter BOSH release
 - Containing the Service Adapter CLI
- Documentation for the operator to configure plan definitions for the Service Adapter
- Documentation for the operator to backup and restore service instances

For information about what is required of the Operator, see [Responsibilities of the Operator](operating.html#responsibility-of-the-operator).

## <a id="create-a-service-release"></a>Creating a Service Release

A service release is a BOSH release that is deployed at instance creation time, once for each service instance, by the on-demand broker (ODB). We have created two examples:

* [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-release)
* [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-release)

See the [BOSH docs](http://bosh.io/docs) for help creating a BOSH release. We recommend creating sample manifests that deploy the service release(s), as this will help you write the `generate-manifest` component of the Service Adapter later.

### Service Instance Lifecycle Errands

 <p class="note"><strong>Note</strong>: This feature requires BOSH director v261 or later.</p>

A service release can provide job errands that can be used by ODB during the management of an instance lifecycle. Service instance lifecycle errands may be [configured by the operator](./operating.html#lifecycle-errands).

ODB supports the following service instance lifecycle errands:

- `post-deploy` - Runs after the creation or updating of a service instance. See the workflow [here](./concepts.html#post-deploy).
- `pre-delete` - Runs before the deletion of a service instance. See the workflow [here](./concepts.html#pre-delete).

A deployment is only considered successful if along with the deployment the lifecycle errand completes successfully.

See an example implementation of a health check post-deploy job in the [example Redis release](https://github.com/pivotal-cf-experimental/redis-example-service-release/tree/b0405ebec76928a83a2d34261403bcbe230168fb/jobs/health-check).

In the [generate-manifest](#generate-manifest) command ensure to validate and include any supported errands that are specified in the instance groups array.

### Service Instance Lifecycle Colocated Errands

<p class="note"><strong>Note</strong>: This feature requires BOSH director v263 or later.</p>

A job errand can be run as a `post-deploy` or `pre-delete` colocated errand. Colocated errands run on an existing service instance group, avoiding additional resource allocation.

In order to enable a new colocated errand, they must be added to the list of jobs of an instance group.

For more information see the [BOSH documentation](https://bosh.io/docs/errands.html).

### Job Links
When generating a manifest, we recommend not using static IPs as this makes network IP management very complex. Instead, we recommend using [BOSH's job links feature](https://bosh.io/docs/links.html).
There are two types of job links, implicit and explicit. The [example Kafka release](https://github.com/pivotal-cf-experimental/kafka-example-service-release/blob/master/jobs/kafka_server/spec#L15) uses implicit job links to get the IPs of the brokers and the zookeeper. Details on how to use the links feature are available [here](https://bosh.io/docs/links.html).

## <a id="create-a-service-adapter"></a>Creating a Service Adapter

A Service Adapter is an executable invoked by ODB. It is expected to respond to these subcommands:

- `generate-manifest`
  Generate a BOSH manifest for your service instance deployment and output to stdout as YAML, given information about the:
  - BOSH Director (stemcells, release names)
  - service instance (ID, request parameters, plan properties, IAAS resources)
  - previous manifest, if this is an upgrade deployment

    **Note**: ODB requires <code>generate-manifest</code> to be idempotent.
    Given the same arguments when a previous manifest is supplied&mdash;which
    happens during a deployment update&mdash;the command should always output
    the same BOSH manifest.

- `dashboard-url`
  Generate an optional URL of a web-based management user interface for the service instance.

- `generate-plan-schemas`
  Generate a JSON schema to validate service-specific configuration parameters. 
  It requires the JSON of a service plan passed via the `--plan-json` flag.

- `create-binding`
  Create (unique, if possible) credentials for the service instance, printing them to stdout as JSON.

- `delete-binding`
  Invalidate the created credentials, if possible. Some services (e.g. Redis) are single-user, and this endpoint will do nothing.



The parameters, and expected output from these subcommands will be explained in detail below. For each of these subcommands, exit status 0 indicates that the command succeeded exit status 10 indicates not implemented, and any non-zero status indicates failure.

### <a id="handling-errors"></a>Handling Errors

If a subcommand fails, the adapter must return a non-zero exit status, and may optionally print to stdout and/or stderr.

When a subcommand exits with an unrecognized exit code anything printed to stdout will be returned to the CF CLI user.

Both the stdout and stderr streams will be printed in the broker log for the operator. For that reason, we recommend not printing the manifest or other sensitive details to stdout/stderr, as the ODB does no validation on this output.

See an example implementation [here](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/892d48b066c9b1d2651080484a53531001e9e920/adapter/create_binding.go#L27-L29).



## <a id="manifest"></a>Inputs for Manifest Generation

### <a id="request-params"></a>Request Parameters

The [body](https://docs.cloudfoundry.org/services/api.html#provisioning) of the provision request from Cloud Controller, including arbitrary parameters from the CLI user.

Service authors can choose to allow Cloud Foundry users to configure service instances with arbitrary parameters. See the PCF docs on [Managing Service Instances with the CLI](https://docs.pivotal.io/pivotalcf/devguide/services/managing-services.html). Arbitrary parameters can be passed to the service adapter when creating, or updating a service instance. They allow Cloud Foundry users to override the default configuration for a service plan.

Service authors must document the usage of arbitrary parameters for Cloud Foundry users.

For example:

- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` arbitrary parameter to configure auto-creation of topics on the cluster.

### <a id="prev-props"></a>Previous Manifest Properties

Service authors can choose to migrate certain properties for the service from the previous manifest when updating a service instance. If the previous manifest is ignored then any properties configured using arbitrary parameters will not be migrated when a service instance is updated.

Service authors must document the migration of previous manifest properties for operators.

For example:

- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports migration of the `auto_create_topics` previous plan property to configure auto-creation of topics on the cluster.

### <a id="plan-props"></a>Service Plan Properties

Service authors can choose to support certain properties for the service in the adapter code. These properties are service-specific traits used to customize the service. They do not necessarily map to jobs one to one; a plan property may affect multiple jobs in the deployment. Plan properties are a mechanism for the operator to define different plans.

Service authors must document the usage of plan properties for the operator.

For example:

- the [Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/<%= vars.odb_example_redis_service_adapter_version %>/adapter/redis_manifest_generator.go) supports the `persistence` property which can be used to attach a disk to the vm.
- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` property to enable auto-creation of topics on the cluster.

### <a id="precedence"></a>Order of Precedence

Note, we recommend service authors use the following order of precedence in their service adapters when generating manifests:

1. arbitrary parameters
1. previous manifest properties
1. plan properties

For example, see `auto_create_topics` in the [example Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L68-L77).

### <a id="defensive-upgrade-behaviors"></a> Defensive Upgrade Behaviors for Stemcells or Releases

Service Authors should ensure that the service release or the stemcell satisfies the functional requirements of the service adapter. This can be achieved, for example, by checking that the service release satisfies a minimum version constraint.

The [generate manifest subcommand for the Kafka example](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/ab99f9086c63396464347b585fb3f2abad6e332c/adapter/generate_manifest.go#L86) has an example of this approach.



## <a id="interface"></a>Service Adapter Interface

A service adapter is expected to be implemented as a binary with the interface

```
service-adapter [subcommand] [params ...]
```

Where the subcommand can be generate-manifest, create-binding, delete-binding

Examples are provided for [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-adapter) and [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter). Note that these Golang examples us the SDK to help with cross-cutting concerns such as unmarshalling the JSON command line parameters. For example, see the use of `HandleCommandLineInvocation` in the [redis-adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/cmd/service-adapter/main.go#L15).

### <a id="sub-commands"></a>Subcommands

#### <a id="generate-manifest"></a>generate-manifest

```
service-adapter generate-manifest [service-deployment-JSON] [plan-JSON] [request-params-JSON] [previous-manifest-YAML] [previous-plan-JSON]
```

The generate-manifest subcommand takes in 5 arguments and returns a BOSH deployment manifest YAML.

<div class="note">
  <strong>Notes</strong>:
  <ul>
    <li>ODB requires <code>generate-manifest</code> to be a <strong>pure function</strong>. Given the same arguments when a previous manifest is supplied&mdash;which happens during a deployment update&mdash;the command should always output the same BOSH manifest.</li>
    <li>When determing whether there are pending changes for an instance during an update, ODB <em>ignores</em> any configuration supplied in the <a href="https://bosh.io/docs/deployment-manifest.html#update" target="_blank">update block of the manifest</a> returned by the <code>generate-manifest</code> subcommand.</li>
  </ul>
</div>

<a id="generate-manifest-output"></a>

##### Output
---

The following table describes the supported exit codes and output for the `generate-manifest` subcommand:

#### Supported Exit Codes for generate-manifest
| exit code     | Description     | Output                                                                                                                           |
|:--------------|:----------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | Stdout: BOSH manifest YAML                                                                                                       |
| 10            | not implemented |                                                                                                                                  |
| anything else | failure         | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

##### Parameters
---

<a id="service-deployment"></a>**service-deployment-JSON**

Provides information regarding the BOSH Director

| field                     | Type              | Description                                                            |
|:--------------------------|:------------------|:-----------------------------------------------------------------------|
| deployment_name           | string            | name of the deployment on the director, in the format `service-instance_$guid`|
| releases                  | array of releases | list of service releases configured for the deployment by the operator |
| release.name              | string            | name of the release on the director                                    |
| release.version           | string            | version of the release                                                 |
| release.jobs              | array of strings  | list of jobs required from the release                                 |
| stemcell                  | map               | the stemcell available on the director                                 |
| stemcell.stemcell_os      | string            | stemcell OS available on the director                                  |
| stemcell.stemcell_version | string            | stemcell version available on the director                             |

For example

```json
{
    "deployment_name": "service-instance_$GUID",
    "releases": [{
        "name": "kafka",
        "version": "dev.42",
        "jobs": [
            "kafka_node",
            "zookeeper"
        ]
    }],
    "stemcell": {
        "stemcell_os": "BeOS",
        "stemcell_version": "2"
    }
}
```

ODB only supports injecting one stemcell into each service deployment (different instance groups cannot have different stemcells).

ODB only supports using exact release and stemcell versions. The use of `latest` and floating stemcells are not supported.

Your Service Adapter should be opinionated about which jobs it requires to generate its manifest. For example, the Kafka example requires `kafka_node` and `zookeeper`. It should not be opinionated about the mapping of BOSH release to job. The jobs can all be provided by one release, or across many. The SDK provides the helper function [`GenerateInstanceGroupsWithNoProperties`](https://github.com/pivotal-cf/on-demand-services-sdk/blob/master/serviceadapter/instance_group_mapping.go) for generating instance groups without any properties. The Kafka example service adapter [uses this helper function](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/adapter.go) and [invokes it](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) to map the service releases parameter to the BOSH manifest `releases` and `instance_groups` sections.

You should provide documentation about which jobs are required by your Service Adapter, and which BOSH releases operators should get these jobs from.

<a id="plan"></a>**plan-JSON**

Plan for which the manifest is supposed to be generated

<a id="plan-schema"></a>
_plan-JSON schema_

| field                                     | Type                     | Description                                                                                                                            |
|:------------------------------------------|:----------------------------|:---------------------------------------------------------------------------------------------------------------------------------------|
| instance_groups                           | array of instance groups    | instance groups configured for the plan                                                                                                |
| instance_group.name                       | string                      | name of the instance group                                                                                                             |
| instance_group.vm\_type                   | string                      | the vm_type configured for the instance group, matches one in the cloud config on the director                                         |
| instance_group.vm\_extensions             | array of strings            | Optional, the vm_extensions configured for the instance group, must be present in the cloud config on the director                     |
| instance_group.persistent\_disk\_type     | string                      | Optional, the persistent\_disk\_type configured for the instance group, matches one in the cloud config on the director                |
| instance_group.networks                   | array of strings            | the networks the instance group is supposed to be in                                                                                   |
| instance_group.instances                  | int                         | number of instances for the instance group                                                                                             |
| instance_group.lifecycle                  | string                      | Optional, specifies the kind of workload the instance group represents. Valid values are `service` and `errand`; defaults to `service` |
| instance_group.azs                        | array of strings            | a list of availability zones that the instance groups should be striped across                                                         |
| instance_group.migrated\_from             | array of migrations         | Optional, list of [bosh migrations](https://bosh.io/docs/migrated-from.html)                                                           |
| migration.name                            | string                      | Optional, name of the instance group to be migrated from                                                                               |
| properties                                | map                         | properties which the operator has configured for deployments of the current plan                                                       |
| lifecycle\_errands                        | map                         | Optional, details of post-deploy and pre-delete errands                                                                                |
| lifecycle\_errands.post\_deploy.name      | string                      | Optional, name of post-deploy errand                                                                                                   |
| lifecycle\_errands.post\_deploy.instances | array of strings            | Optional, for a colocated errand, specify a list of INSTANCE-NAME/INSTANCE_IDX to run the errand                                       |
| lifecycle\_errands.pre\_delete            | array of pre_delete errands | Optional, list of errands to complete before deletion                                                                                  |
| lifecycle\_errands.pre\_delete.name       | string                      | Optional, name of pre-delete errand                                                                                                    |
| lifecycle\_errands.pre\_delete.instances  | array of strings            | Optional, for a colocated errand, specify a list of INSTANCE-NAME/INSTANCE_IDX to run the errand                                       |
| update                                    | map                         | update block which the operator has configured for deployments of the current plan                                                     |
| update.canaries                           | int                         | plan-specific number of canary instances                                                                                               |
| update.max\_in\_flight                    | int                         | plan-specific maximum number of non-canary instances to update in parallel                                                             |
| update.canary\_watch\_time                | string                      | plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the canary instances are healthy              |
| update.update\_watch\_time                | string                      | plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the non-canary instances are healthy          |
| update.serial                             | boolean                     | Optional, plan-specific flag to deploy instance groups sequentially (`true`), or in parallel (`false`); defaults to `true`             |

For example

```json
{
  "instance_groups": [
    {
      "name": "example-server",
      "vm_type": "small",
      "vm_extensions": [
        "some",
        "extensions"
      ],
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "azs": [
        "example-az"
      ],
      "instances": 1,
      "migrated_from": [
        {
          "name": "old-example-server"
        }
      ]
    },
    {
      "name": "example-migrations",
      "vm_type": "small",
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "instances": 1,
      "lifecycle": "errand"
    }
  ],
  "properties": {
    "example": "property"
  },
  "lifecycle_errands": {
    "post_deploy": {
      "name": "health-check"
    },
    "pre_delete": [
      {
        "name": "cleanup",
        "instances": [
          "example-server/0"
        ]
      }
    ]
  },
  "update": {
    "canaries": 1,
    "max_in_flight": 2,
    "canary_watch_time": "1000-30000",
    "update_watch_time": "1000-30000",
    "serial": true
  }
}
```

Plans are composed by the operator and consist of resource mappings, properties and an optional update block:

* **Resource Mappings**

  The `instance_groups` section of the plan JSON. This maps service deployment instance groups (defined by the service author) to resources (defined by the operator). The service developers should document the list of instance group names required for their deployment (e.g. "redis-server") and any constraints they recommend on resources (e.g. operator must add a persistent disk if persistence property is enabled). These constraints can of course be enforced in code. The `instance_groups` section also contains a field for `lifecycle`, which can be set by the operator. The service adapter will add a lifecycle field to the instance group within the BOSH manifest when specified.

* **Properties**

  Properties are service-specific parameters chosen by the service author. The Redis example exposes a property `persistence`, which takes a boolean value and toggles disk persistence for Redis. These should be documented by the service developers for the operator.

* **Update Block (optional)**

  This block defines a plan-specific configuration for BOSH's update instance operation. Although the ODB considers this block optional, the service adapter must output an update block in every manifest it generates. Some ways to achieve that are:

  1. *(Recommended)* Define a default update block for all plans, which is used when a plan-specific update block is not provided by the operator
  1. Hard code an update block for all plans in the service adapter
  1. Make the update block mandatory, so that operators must provide an update block for every plan in the service catalogue section of the ODB manifest

<a id="generate-request-params-JSON"></a>**request-params-JSON**

This is a JSON object that holds the entire body of the [service provision](http://docs.cloudfoundry.org/services/api.html#provisioning) or [service update](http://docs.cloudfoundry.org/services/api.html#updating_service_instance) request sent by the Cloud Controller to the service broker. The request parameters JSON will be `null` for upgrades.

The field `context` holds platform specific contextual information under which the service instance is to be provisioned.

The field `parameters` contains arbitrary key-value pairs which were passed by the application developer as a `cf` CLI parameter when creating, or updating the service instance.

Note: when updating an existing service instance, any arbitrary parameters passed on a previous create or update will not be passed again. Therefore, for arbitrary parameters to stay the same across multiple deployments they must be retrieved from the previous manifest.

For example

```
{
  "context": {
    "platform": "cloudfoundry",
    "some_field": "some-contextual-data"
  },
  "organization_guid": "org-guid-here",
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "plan-id-here",
  "service_id": "service-id-here",
  "space_guid": "space-guid-here"
}
```

<a id="previous-manifest"></a>**previous-manifest-YAML**

The previous manifest as YAML. The previous manifest is nil if this is a new deployment. The format of the manifest should match the [BOSH v2 manifest](https://bosh.io/docs/manifest-v2.html).

It is up to the service author to perform any necessary service-specific migration logic here, if previous manifest is non-nil.

Another use-case of the previous manifest is for the migration of deployment properties which need to stay the same across multiple deployments of a manifest. For example in the Redis example, we [generate a password](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L112-L123) when we do a new deployment. But when the previous deployment manifest is provided, we copy the password over from [the previous deployment](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338), as generating a new password for existing deployments will break existing bindings.

For example see the [example Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338).

<a id="previous-plan"></a>**previous-plan-JSON**
The previous plan as JSON. The previous plan is nil if this is a new deployment. The format of the plan should match [plan schema](#plan-schema). The previous plan can be used for complex plan migration logic, for example the [kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L27:L33), rejects a plan migration if the new plan reduces the number of instances, to prevent data loss.

---

#### <a id="dashboard-url"></a>dashboard-url

```
service-adapter dashboard-url [instance-ID] [plan-JSON] [manifest-YAML]
```

The `dashboard-url` subcommand takes in 3 arguments and returns a JSON with the `dashboard_url`. The dashboard URL is optional. If no dashboard URL is relevant to the service, the subcommand should exit with code 10. Provisioning will be successful without the dashboard URL.

##### <a id="dashboard-url-output"></a>Output
---

If the `dashboard-url` command generates a url successfully, it should exit with 0 and return a dashboard URL JSON with the following structure:


| field         | Type   | Description                           |
|:--------------|:-------|:--------------------------------------|
| dashboard_url | string | dashboard url returned to the cf user |

```
{
   "dashboard_url":"https://someurl.example.com"
}
```

#### Supported Exit Codes for dashboard-url

| exit code     | Description     | Output                                                                                                                           |
|:--------------|:----------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | Stdout: dashboard URL JSON                                                                                                       |
| 10            | not implemented |                                                                                                                                  |
| anything else | failure         | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

##### Parameters
---

<a id="dashboard-url-instance-id"></a>**instance-ID**

Provided by the cloud controller which uniquely identifies the service-instance.

e.g. `42a09f38-c15b-47fe-a24e-ebf5f83ebd0`

<a id="dashboard-url-plan"></a>**plan-JSON**

Current plan for the service instance as JSON. The structure should be the same as the [plan given in the generate manifest](#plan).

For example

```json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": {},
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```

<br>
<a id="dashboard-url-manifest"></a>**manifest-YAML**

The current manifest as YAML. The format of the manifest should match the [BOSH] v2 manifest](https://bosh.io/docs/manifest-v2.html).

For example

```yaml
name: my-service-instance
releases:
- name: my-service
  version: 1.1.0
stemcells:
- alias: only-stemcell
  os: ubuntu-trusty
  version: "3468.1"
instance_groups:
- name: my-example-server
  instances: 1
  jobs:
  - name:  my-example-server
    release: my-service
  vm_type: t2.small
  stemcell: only-stemcell
  persistent_disk_type: 10GB
  azs:
  - z1
  networks:
  - name: default
  properties:
    some-parameter:
      param1: "some-value"
      param2: 1
update:
  canaries: 4
  canary_watch_time: 30000-240000
  update_watch_time: 30000-240000
  max_in_flight: 4
tags:
  product: my-product
```

---

#### <a id="create-binding"></a>create-binding

```
service-adapter create-binding [binding-ID] [bosh-VMs-JSON] [manifest-YAML] [request-params-JSON]
```

Binding credentials for a service instance should share a namespace, and should be unique if possible. E.g. for MySQL, two bindings could include a different username/password pairs, but share the same MySQL database tables and data. The first step is to determine which credentials are best to supply in the context of your service. We recommend that users can be identified statelessly from the binding ID, and the simplest way to do this is to name the user after the binding ID.

##### <a id="create-binding-output"></a>Output
---

If the `create-binding` command is successful, it should return an exit code of 0 and print a [service broker API binding JSON response](http://docs.cloudfoundry.org/services/api.html#binding) on stdout. An example response is shown below. If the command failed, it should return any non-zero exit code, see the [supported exit code table](#create-binding-exit-codes) for details of supported failure cases. Stdout and stderr from the command will be logged by the ODB.

Example success response to `create-binding`:

```json
{
  "credentials": {
    "username": "user1",
    "password": "reallysecret"
  },
  "syslog_drain_url": "optional: for syslog drain services only",
  "route_service_url": "optional: for route services only"
}
```

#### <a id="create-binding-exit-codes"></a>Supported Exit Codes for Binding

| exit code     | Description                                       | Output                                                                                                                           |
|:--------------|:--------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                                           | Stdout: binding credentials JSON                                                                                                 |
| 10            | subcommand not implemented                        |                                                                                                                                  |
| 42            | app_guid not provided in the binding request body | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| 49            | binding already exists                            | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| anything else | failure                                           | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

##### Parameters
---

<a id="create-binding-id"></a>**binding-ID**

The binding-ID generated by the Cloud Controller.

<a id="create-bosh-vms-json"></a>**bosh-VMs-JSON**

A map of instance group name to an array of IPs provisioned for that instance group.

For example

```json
{
  "mysql_node": ["192.0.2.1", "192.0.2.2", "192.0.2.3"],
  "management_box": ["192.0.2.4"]
}
```

This can be used to connect to the instance deployment if required, to create a service specific binding. In the example above, the Service Adapter may connect to MySQL as the admin and create a user. As part of the binding, the `mysql_node` IPs would be returned, but maybe not the `management_box`.

<a id="create-binding-manifest"></a>**manifest-YAML**

The current manifest as YAML. This is used to extract information about the deployment that is necessary for the binding (e.g. admin credentials with which to create users). The format of the manifest should match the [BOSH v2 manifest](https://bosh.io/docs/manifest-v2.html)

<a id="create-request-params-JSON"></a>**request-params-JSON**

This is a JSON object that holds the entire body of the [service
binding](http://docs.cloudfoundry.org/services/api.html#binding) request sent
by the Cloud Controller to the service broker.

The field `parameters` contains arbitrary key-value pairs which were passed by
the application developer as a `cf` CLI parameter when creating, or updating
the service instance. If using the <a href="#sdk">golang SDK</a>, it can be
obtained using the `ArbitraryParams()` helper method on requestParams.

The field `bind_resource` contains key-value pairs for `app_guid`,
`credential_client_id` and `route`.  If using the <a href="#sdk">golang
SDK</a>, the `brokerapi.BindResource` struct containing these fields can be
accessed using the `BindResource()` helper method on requestParams.

For example

```json
{
  "app_guid": "app-guid-here",
  "bind_resource": {
    "app_guid": "app-guid-here"
  },
  "context": {
    "platform": "cloudfoundry",
    "some_param": "some-value"
  },
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "my-plan",
  "service_id": "my-service"
  }
  ```

#### Credentials for Bindings

We have identified three approaches to credentials for a service binding.

**Static Credentials**

In this case, the same credentials are used for all bindings. One option is to define these credentials in the service instance manifest.

This scenario makes sense for services that use the same credentials for all bindings, such as Redis. For example:

```yaml
properties:
  redis:
    password: PASSWORD
```

**Credentials Unique to Each Binding**

In this case, when the adapter `generate-manifest` subcommand is invoked, it generates random admin credentials and returns them as part of the service instance manifest. When the `create-binding` subcommand is invoked, the adapter can use the admin credentials from the manifest to create unique credentials for the binding. Subsequent `create-binding`s create new credentials.

This option makes sense for services whose binding creation resembles user creation, such as MySQL or RabbitMQ. For example, in MySQL the admin user can be used to create a new user and database for the binding:

```yaml
properties:
  admin_password: ADMIN-PASSWORD
```

**Using an Agent**

In this case, the author defines an agent responsible for handling creation of credentials unique to each binding. The agent must be added as a BOSH release in the service manifest. Moreover, the service and agent jobs should be co-located in the same instance group.

This option is useful for services where the adapter cannot or prefers not to directly call out to the service instance, and instead delegates responsibility for setting up new credentials to an agent.

For example:

```yaml
releases:
  - name: service-release
    version: 1.5.7
  - name: credentials-agent-release
    version: 4.2.0

instance_groups:
  - name: service-group
    jobs:
      - name: service-job
        release: service-release
      - name: credentials-agent-job
        release: credentials-agent-release
```

---

### <a id="delete-binding"></a>delete-binding

```
service-adapter delete-binding [binding-ID] [bosh-VMs-JSON] [manifest-YAML] [delete-params-JSON]
```

This should invalidate the credentials that were generated by `create-binding` if possible. E.g. for MySQL, it would delete the binding user.

##### <a id="delete-binding-output"></a>Output
---

The following table describes the supported exit codes and output for the `delete-binding` subcommand:

#### Supported Exit Codes for delete-binding
| exit code     | Description            | Output                                                                                                                           |
|:--------------|:-----------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | No output is required                                                                                                            |
| 10            | not implemented        |                                                                                                                                  |
| 41            | binding does not exist | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| anything else | failure                | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

##### Parameters
---

<a id="delete-binding-id"></a>**binding-ID**

The binding to be deleted.

<a id="delete-binding-vm-json"></a>**bosh-VMs-JSON**

A map of instance group name to an array of IPs provisioned for that instance group.

For example

```json
{
  "my-instance-group": ["192.0.2.1", "192.0.2.2", "192.0.2.3"]
}
```

This can be used to connect to the actual VMs if required, to delete a service specific binding. For example delete a user in MySQL.

<a id="delete-binding-manifest"></a>**manifest-YAML**

The current manifest as YAML. This is used to extract information about the deployment that is necessary for the binding (e.g. credentials). The format of the manifest should match the [BOSH v2 manifest](https://bosh.io/docs/manifest-v2.html)

For example see the [kafka delete binding](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/delete_binding.go)

<a id="delete-params-JSON"></a>**delete-params-JSON**

This is a JSON object that holds query string parameters as useful hints for service brokers. [service unbinding](http://docs.cloudfoundry.org/services/api.html#unbinding)

For example

```json
{
  "plan_id":"my-plan-id",
  "service_id":"my-service-id"
}
```


<p class="note"><strong>Note</strong>: This parameter is different from the 
  create-binding <code>request-params-JSON</code> parameter, and in particular
  does not include <code>parameters</code> or <code>bind_resource</code>.</p>

---

### <a id="generate-plan-schemas"></a>generate-plan-schemas

```
service-adapter generate-plan-schemas [--plan-json]
```

The `generate-plan-schemas` subcommand takes the JSON for a service plan and 
returns a schema that validates service-specific configuration parameters.

##### <a id="generate-plan-schemas-output"></a>Output
---

The following table describes the supported exit codes and output for the 
`generate-plan-schemas` subcommand:

#### Supported Exit Codes for delete-binding
| exit code     | Description            | Output                                                                                                                           |
|:--------------|:-----------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | No output is required                                                                                                            |
| 10            | not implemented        |                                                  |
| anything else | failure                | Stdout: optional error message for cf CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

##### Parameters
---


<a id="plan-json"></a>**plan-json**

The service plan as JSON required to generate the JSON schema.

For example

```json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": {},
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```


## <a id="packaging"></a>Packaging

This topic describes workflows for setting up and maintaining of a service instance. The diagrams show which tasks are undertaken by the ODB and which require interaction with the Service Adapter.

The adapter should be packaged as a BOSH release, which should be co-located with the ODB release in a BOSH manifest by the operator. This is only done in order to place the adapter executable on the same VM as the ODB server, therefore the adapter BOSH job's `monit` file should probably have no processes defined.

Example service adapter releases:

- <a href="https://github.com/pivotal-cf-experimental/kafka-example-service-adapter-release">Kafka</a>
- <a href="https://github.com/pivotal-cf-experimental/redis-example-service-adapter-release">Redis</a>

## <a id="sdk"></a> Golang SDK

We have published a [SDK](https://github.com/pivotal-cf/on-demand-services-sdk) for teams writing their service adapters in Golang. It encapsulates the command line invocation handling, parameter parsing, response serialization and error handling so the adapter authors can focus on the service-specific logic in the adapter.

You should use the same version of the SDK as your ODB release. For example if you are using v0.8.0 of the ODB BOSH release you should checkout the v0.8.0 tag of the SDK.

For the generated BOSH manifest the SDK supports properties in two levels: manifest (global) and job level. Global properties are [deprecated in BOSH](http://bosh.io/docs/manifest-v2.html#properties), in favour of job level properties and job links. As an example, refer to the [Kafka example service adapter property generation](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/ffe85fecc2d9cf1b663fab418875e67ddcf3327f/adapter/generate_manifest.go#L79-L123).

### <a id="sdk_usage"></a>Usage

Get the SDK:

```sh
go get github.com/pivotal-cf/on-demand-services-sdk
```

In the main function for the service adapter, call the `HandleCLI` function:

```go
package main

import (
	"log"
	"os"

	"github.com/bar-org/foo-service-adapter/adapter"
	"github.com/pivotal-cf/on-demand-services-sdk/serviceadapter"
)

func main() {
  logger := log.New(os.Stderr, "[foo-service-adapter] ", log.LstdFlags)
  manifestGenerator := adapter.ManifestGenerator{}
  binder := adapter.Binder{}
  dashboardUrlGenerator := adapter.DashboardUrlGenerator{}
	handler := serviceadapter.CommandLineHandler{
  	ManifestGenerator:     manifestGenerator,
  	Binder:                binder,
  	DashboardURLGenerator: &adapter.DashboardUrlGenerator{},
  	SchemaGenerator:       adapter.SchemaGenerator{},
	}
  serviceadapter.HandleCLI(os.Args, handler)
}
```
<p class="note"><strong>Note</strong>: The HandleCommandLineInvocation function is being deprecated but its functionality can be seen <a href="https://docs.pivotal.io/svc-sdk/odb/0-19/creating.html#usage">here</a>.</p>

### <a id="interfaces"></a>Interfaces

The `HandleCLI` function accepts structs that implement these interfaces:

```go
type CommandLineHandler struct {
	ManifestGenerator     ManifestGenerator
	Binder                Binder
	DashboardURLGenerator DashboardUrlGenerator
	SchemaGenerator       SchemaGenerator
}

type ManifestGenerator interface {
	GenerateManifest(serviceDeployment ServiceDeployment, plan Plan, requestParams RequestParameters, previousManifest *bosh.BoshManifest, previousPlan *Plan) (bosh.BoshManifest, error)
}

type Binder interface {
	CreateBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest, requestParams RequestParameters) (Binding, error)
	DeleteBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest, requestParams RequestParameters) error
}

type DashboardUrlGenerator interface {
	DashboardUrl(instanceID string, plan Plan, manifest bosh.BoshManifest) (DashboardUrl, error)
}

type SchemaGenerator interface {
	GeneratePlanSchema(plan Plan) (PlanSchema, error)
}
```

### <a id="helper_function"></a>Helpers

The helper function `GenerateInstanceGroupsWithNoProperties` can generate the
instance groups for the BOSH manifest from the arguments passed to the adapter.

One of the inputs for this function is `deploymentInstanceGroupsToJobs`,
where instance groups are mapped to jobs for the deployment.
The service author must provide this mapping.
The helper function does not address job level properties for the generated instance groups;
the service author must provide these properties.
For an example implementation, see the job mapping in the [Kafka example
adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L15-L21).

The SDK provides the methods `ArbitraryContext` and `Platform`. These are
used to extract the `context` property from the request parameters and the `platform` property from within the
`context`.

The context in the response is a feature of [Open Service Broker API (OSBAPI) specification
v2.13](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)
and is used to pass through information about the environment in which the
platform or application is executing. If the platform does not provide a `context`, the SDK returns empty values.

### <a id="error_handling"></a>Error Handling

Any error returned by the interface functions is considered to be for the Cloud Foundry CLI user and will accordingly be printed to stdout.

The adapter code is responsible for performing any error logging to stderr that the authors think is relevant for the operator logs.

There are three specialised errors for the `CreateBinding` function, which allow the adapter to exit with the appropriate code:

```go
serviceadapter.NewBindingAlreadyExistsError()
serviceadapter.NewBindingNotFoundError()
serviceadapter.NewAppGuidNotProvidedError()
```

For more complete code examples please take a look at the [kafka adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter) or the [redis adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter).

### <a id="bosh_features"></a>BOSH Features

Service authors can enable configuration of BOSH Features in their service adapters.

The SDK provides the following [BoshFeatures struct](https://github.com/pivotal-cf/on-demand-services-sdk/blob/49cf3649cd34db8715b673d42e36710517e0f30e/bosh/bosh_manifest.go#L36-L45) 
with the possibility of adding extra features via the `ExtraFeatures` map.

```
type BoshFeatures struct {
	UseDNSAddresses      *bool                  `yaml:"use_dns_addresses,omitempty"`
	RandomizeAZPlacement *bool                  `yaml:"randomize_az_placement,omitempty"`
	UseShortDNSAddresses *bool                  `yaml:"use_short_dns_addresses,omitempty"`
	ExtraFeatures        map[string]interface{} `yaml:"extra_features,inline"`
}
```

For an example, see [redis adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/4f78b89d791733d025ae96f4056eb6840989818e/adapter/redis_manifest_generator.go#L215-L222).

For more information on BOSH Features, see [the BOSH documentation](https://bosh.io/docs/manifest-v2.html#features).
