---
title: Service Adapter Interface Reference
owner: London Services Enablement
---

This topic describes the subcommands used with the Service Adapter Interface.


## <a id="interface"></a>Service Adapter Interface

Implement your service adapter as a binary.
The service adapter receives its parameters as a JSON document using stdin.

For example service adapters, see the following examples written in golang:

* [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-adapter)
* [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter)

<p class="note"><strong>Note: </strong> The Redis and Kafka examples above use the SDK to help with
  cross-cutting concerns. For example, reading the JSON document from stdin.</p>

A service adapter is expected to respond to the subcommands.
For each of these subcommands, the following applies:

* An exit status of `0` indicates that the command succeeded.
* An exit status of `10` indicates not implemented.
* Any non-zero exit status indicates failure.

For a list of possible subcommands and the structure of the JSON document
passed via stdin, see the subcommands below.

## <a id="generate-manifest"></a>generate-manifest

This section contains the following topics:

- [Input Parameters](#generate-manifest-parameters)
- [Output](#generate-manifest-output)

<div class="note">
  <strong>Notes</strong>:
  <ul>
  <li>The on-demand broker (ODB) requires <code>generate-manifest</code> to be
    <strong>idempotent</strong>.
    Given the same arguments when a previous manifest is
    supplied&mdash;which happens during a deployment update&mdash;the command
    should always output the same BOSH manifest.</li> <li>When determining
    whether there are pending changes for an instance during an update, ODB
    <em>ignores</em> any configuration supplied in the <a
    href="https://bosh.io/docs/deployment-manifest.html#update"
    target="_blank">update block of the manifest</a> returned by the
    <code>generate-manifest</code> subcommand.</li>
    <li>
    Service Authors should ensure that the service releases and stemcells
    satisfy the functional requirements of the service adapter. This can be
    achieved, for example, by checking that the service release satisfies a minimum
    version constraint.
    </li>
  </ul>
</div>

###<a id="generate-manifest-parameters"></a>Input Parameters

This section details the parameters provided to the `generate-manifest` subcommand using stdin.

See the following example:

```json
{
  "generate_manifest": {
    "service_deployment": "SERVICE-DEPLOYMENT-JSON",
    "plan": "PLAN-JSON",
    "previous_plan": "PREVIOUS-PLAN-JSON",
    "previous_manifest": "PREVIOUS-MANIFEST-YAML",
    "request_parameters": "REQUEST-PARAMETERS-JSON",
    "previous_secrets": "PREVIOUS-SECRETS-JSON",
    "previous_configs": "PREVIOUS-CONFIGS-JSON"
  }
}
```
<br>
All arguments are passed as strings, not JSON objects.

For example:

```not-json
{
  "generate_manifest": {
    "service_deployment": "{\"deployment_name\":\"some-name\"...}"
    // ...
  }
}
```

<div class="note">
  <strong>Note</strong>:
  Pivotal recommends that service authors use the following order of precedence in their
  service adapters when generating manifests:<br><br>
  <ol>
    <li>Arbitrary parameters</li>
    <li>Previous manifest properties</li>
    <li>Plan properties</li>
  </ol>
  For an example, see <code>auto_create_topics</code> in the
  <a href="https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L68-L77"> example Kafka service adapter</a>.
</div>

####<a id="service-deployment"></a>SERVICE-DEPLOYMENT-JSON

`SERVICE-DEPLOYMENT-JSON` provides information regarding the BOSH Director.

The following table describes the JSON structure required for `SERVICE-DEPLOYMENT-JSON`:

| Field                     | Type               | Description                                                            |
|:--------------------------|:-------------------|:-----------------------------------------------------------------------|
| deployment_name           | string             | Name of the deployment on the Director, in the format `service-instance_GUID`|
| releases                  | array of releases  | List of service releases configured for the deployment by the operator |
| release.name              | string             | Name of the release on the Director                                    |
| release.version           | string             | Version of the release                                                 |
| release.jobs              | array of strings   | List of jobs required from the release                                 |
| stemcells                 | array of stemcells | The stemcells available on the Director                                |
| stemcell.stemcell_os      | string             | Stemcell OS available on the Director                                  |
| stemcell.stemcell_version | string             | Stemcell version available on the Director                             |
<br>
For example:

```json
{
    "deployment_name": "service-instance_GUID",
    "releases": [{
        "name": "kafka",
        "version": "dev.42",
        "jobs": [
            "kafka_node",
            "zookeeper"
        ]
    }],
    "stemcells": [{
        "stemcell_os": "BeOS",
        "stemcell_version": "2"
    }, {
        "stemcell_os": "Windows",
        "stemcell_version": "3"
    }]
}
```
<br>
Keep in mind the following:

* ODB only supports using exact release and stemcell versions. The use of `latest` and floating stemcells are not supported.
* Your Service Adapter should be opinionated about which jobs it requires to generate its manifest.
  For example, the Kafka example requires `kafka_node` and `zookeeper`.
  It should not be opinionated about the mapping of BOSH release to job.
  The jobs can all be provided by one release or across many.
  The SDK provides the helper function [`GenerateInstanceGroupsWithNoProperties`](https://github.com/pivotal-cf/on-demand-services-sdk/blob/master/serviceadapter/instance_group_mapping.go) for generating instance groups without any properties.
  The Kafka example service adapter [uses this helper function](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/adapter.go)
  and [invokes it](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go)
  to map the service releases parameter to the BOSH manifest `releases` and `instance_groups` sections.
* You should provide documentation about which jobs are required by your Service Adapter, and which BOSH releases operators should get these jobs from.

####<a id="plan-json"></a>PLAN-JSON

`PLAN-JSON` specifies the plan that the manifest is generated for.

The following table describes the schema of the JSON structure required for `PLAN-JSON`:

| Field                                     | Type                     | Description                                                                                                                            |
|:------------------------------------------|:-------------------------|:---------------------------------------------------------------------------------------------------------------------------------------|
| instance_groups                           | array of instance groups | Instance groups configured for the plan                                                                                                |
| instance_group.name                       | string                   | Name of the instance group                                                                                                             |
| instance_group.vm\_type                   | string                   | The vm_type configured for the instance group, matches one in the cloud config on the director                                         |
| instance_group.vm\_extensions             | array of strings         | Optional, the vm_extensions configured for the instance group, must be present in the cloud config on the director                     |
| instance_group.persistent\_disk\_type     | string                   | Optional, the persistent\_disk\_type configured for the instance group, matches one in the cloud config on the director                |
| instance_group.networks                   | array of strings         | The networks the instance group is supposed to be in                                                                                   |
| instance_group.instances                  | int                      | Number of instances for the instance group                                                                                             |
| instance_group.lifecycle                  | string                   | Optional, specifies the kind of workload the instance group represents. Valid values are `service` and `errand`; defaults to `service` |
| instance_group.azs                        | array of strings         | A list of availability zones that the instance groups should be striped across                                                         |
| instance_group.migrated\_from             | array of migrations      | Optional, list of [bosh migrations](https://bosh.io/docs/migrated-from.html)                                                           |
| migration.name                            | string                   | Optional, name of the instance group to be migrated from                                                                               |
| properties                                | map                      | Properties which the operator has configured for deployments of the current plan                                                       |
| lifecycle\_errands                        | map                      | Optional, details of post-deploy and pre-delete errands                                                                                |
| lifecycle\_errands.post\_deploy           | array of errands         | Optional, post-deploy errands configured for the plan                                                                                  |
| lifecycle\_errands.pre\_delete            | array of errands         | Optional, pre-delete errands configured for the plan                                                                                   |
| errand.name                               | string                   | Errand name                                                                                                                            |
| errand.instances                          | array of strings         | Optional, for a colocated errand, specify a list of INSTANCE-NAME/INSTANCE-IDX to run the errand                                       |
| update                                    | map                      | Update block which the operator has configured for deployments of the current plan                                                     |
| update.canaries                           | int                      | Plan-specific number of canary instances                                                                                               |
| update.max\_in\_flight                    | int                      | Plan-specific maximum number of non-canary instances to update in parallel                                                             |
| update.canary\_watch\_time                | string                   | Plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the canary instances are healthy              |
| update.update\_watch\_time                | string                   | Plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the non-canary instances are healthy          |
| update.serial                             | boolean                  | Optional, plan-specific flag to deploy instance groups sequentially (`true`), or in parallel (`false`); defaults to `true`             |
<br>
For example:

```json
{
  "instance_groups": [
    {
      "name": "example-server",
      "vm_type": "small",
      "vm_extensions": [
        "some",
        "extensions"
      ],
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "azs": [
        "example-az"
      ],
      "instances": 1,
      "migrated_from": [
        {
          "name": "old-example-server"
        }
      ]
    },
    {
      "name": "example-migrations",
      "vm_type": "small",
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "instances": 1,
      "lifecycle": "errand"
    }
  ],
  "properties": {
    "example": "property"
  },
  "lifecycle_errands": {
    "post_deploy": [
      {
        "name": "health-check"
      },
      {
        "name": "init-replication",
        "instances": ["primary-node/0"]
      }
    ],
    "pre_delete": [
      {
        "name": "cleanup",
        "instances": ["example-server/0"]
      }
    ]
  },
  "update": {
    "canaries": 1,
    "max_in_flight": 2,
    "canary_watch_time": "1000-30000",
    "update_watch_time": "1000-30000",
    "serial": true
  }
}
```

<br>
Plans are composed by the operator and consist of resource mappings, properties,
and an optional update block.

<br>
 **Resource Mappings**

  The `instance_groups` section of the plan JSON.
  This maps service deployment instance groups (defined by the service author) to
  resources (defined by the operator).

  You should document the list of instance group names required for a deployment,
  for example, "redis-server".
  You should also document any recommended resource constraints. For example,
  operators must add a persistent disk if the persistence property is enabled.
  You can enforce these constraints in code.

  The `instance_groups` section also contains a field for `lifecycle`, which can
  be set by the operator.
  The service adapter adds a `lifecycle` field to the instance group within the BOSH
  manifest when specified.

<br>
**Properties**

  Properties are service-specific parameters that you choose.
  The Redis example exposes a property `persistence`, which takes a boolean value
  and toggles disk persistence for Redis.
  You should document these properties for the operator.

<br>
 **(Optional) Update Block**

  This block defines a plan-specific configuration for BOSH's update instance operation.
  Although the ODB considers this block optional, the service adapter must output
  an update block in every manifest it generates.
  Some ways to achieve that are:

  1. *(Recommended)* Define a default update block for all plans, which is used
  when a plan-specific update block is not provided by the operator.
  1. Hard code an update block for all plans in the service adapter.
  1. Make the update block mandatory, so that operators must provide an update
  block for every plan in the service catalog section of the ODB manifest.

####<a id="generate-request-params-JSON"></a>REQUEST-PARAMS-JSON

This is a JSON object that holds the entire body of the [service
provision](http://docs.cloudfoundry.org/services/api.html#provisioning) or
[service
update](http://docs.cloudfoundry.org/services/api.html#updating-a-service-instance)
request sent by the Cloud Controller to the service broker. The request
parameters JSON will be `null` for upgrades.

The field `context` holds platform-specific contextual information under which
the service instance is to be provisioned.

The field `parameters` contains arbitrary key-value pairs that were passed by
the application developer as a cf CLI parameter when creating or updating
the service instance. They allow Cloud Foundry users to override the
default configuration for a service plan. For example, the [Kafka service
adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go)
supports the `auto_create_topics` arbitrary parameter to configure
auto-creation of topics on the cluster.

<p class="note"><strong>Note</strong>: When updating an existing service instance,
   any arbitrary parameters passed on a previous create or update are not passed again.
   Therefore, for arbitrary parameters to stay the same across multiple deployments
   they must be retrieved from the previous manifest.</p>
<br>
For example:

```
{
  "context": {
    "platform": "cloudfoundry",
    "some_field": "some-contextual-data"
  },
  "organization_guid": "org-guid-here",
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "plan-id-here",
  "service_id": "service-id-here",
  "space_guid": "space-guid-here"
}
```

####<a id="previous-manifest"></a>PREVIOUS-MANIFEST-YAML

`PREVIOUS-MANIFEST-YAML` represents the previous BOSH deployment manifest for
the service instance. If you have a new deployment, the YAML file is empty.

The manifest format matches the BOSH v2 manifest. For more information about the
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in
the BOSH documentation.

The service author must perform any necessary service-specific migration logic if
previous manifest is non-nil.

Another use case of the previous manifest is for the migration of deployment properties
which need to stay the same across multiple deployments of a manifest. In the Redis example,
we [generate a password](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L112-L123) when we do a new deployment.
But, when the previous deployment manifest is provided, we copy the password over from [the
previous deployment](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338), because generating a new
password for existing deployments will break existing bindings.

For an example, see the [example Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338).

<p class="note warning"><strong>WARNING</strong>:
  If the service adapter does not migrate properties from the old manifest to
  the new one, the update fails.</p>

####<a id="previous-plan"></a>PREVIOUS-PLAN-JSON

This argument takes the previous plan as a JSON string.

The previous plan is nil if this is a new deployment.

The format of the plan should match the [plan schema](#plan-schema). The previous plan
can be used for complex plan migration logic. For an example, the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L27:L33)
 rejects a plan migration if the new plan reduces the number of instances, to prevent data loss.

####<a id="previous-secrets"></a>PREVIOUS-SECRETS-JSON

If `enable_secure_manifests` is set to `true` in the broker, any secrets
that use references to BOSH-generated variables or literal CredHub paths in the
previous service instance manifest are resolved and sent to the adapter in the
`PREVIOUS-SECRETS-JSON` parameter.

These secrets are passed during updates but not during upgrades.

If `enable_secure_manifests` is set to `false` in the broker, then the
`PREVIOUS-SECRETS-JSON` parameter is empty.

The following is an example previous service instance manifest:

```
...
password: ((redis_password))
root_ca: ((/global/root_ca))

variables:
- name: redis_password
  type: password
```

<br>
The service instance manifest snippet above produces a secrets JSON parameter
similar to the following.  The keys are the reference names, and the values are
the resolved secrets:

```
{
  "((redis_password))": "some-bosh-generated-password",
  "((/global/root_ca))": "some-global-value"
}
```

<p class="note"><strong>Note:</strong> You can find the secrets key by accessing
the manifest field that contains the reference to the variable.</p>

####<a id="previous-configs"></a>PREVIOUS-CONFIGS-JSON

This argument provides the previous BOSH configs specified for the service
instance. If populated, it will contain a map of config types to config content.
For example:

```json
{
  "cloud":"
    vm_types:
     - name: my-service-instance-small
       cloud_properties:
         cpu: 1"
}
```

###<a id="generate-manifest-output"></a>Output

The following table describes the supported exit codes and output for the
`generate-manifest` subcommand:

| Exit code     | Description     | Output                                                                                                                           |
|:--------------|:----------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | <ul><li>Stdout: JSON document containing the BOSH manifest YAML, a map of adapter-generated secrets to be managed by ODB, and a map of BOSH configs</li></ul>                 |
| 10            | not implemented |                                                                                                                                  |
| anything else | failure         | <ul><li>Stdout: optional error message for CF CLI users</li> <li>Stderr: error message for operator</li> <li>ODB logs both stdout and stderr</li></ul>     |

<br>
Example JSON output printed when the `generate-manifest` command is successful:

```json
{
  "manifest": "GENERATED-BOSH-MANIFEST-YAML",
  "secrets": { "secret1":"value1", "secret2":"value2" },
  "configs": {
    "cloud":"
       vm_types:
       - name: my-service-instance-small
         cloud_properties:
           cpu: 1"
  }
}
```

##<a id="dashboard-url"></a>dashboard-url

This section contains the following topics:

- [Input Parameters](#dashboard-url-parameters)
- [Output](#dashboard-url-output)

###<a id="dashboard-url-parameters"></a>Input Parameters

The following section details the parameters provided to the `dashboard-url` subcommand using stdin.

See the following example:

```json
{
  "dashboard_url": {
    "instance_id": "SERVICE-INSTANCE-ID",
    "plan": "PLAN-JSON",
    "manifest": "MANIFEST-YAML"
  }
}
```

<br>
All the arguments are passed as strings and not JSON objects.

For example:

```not-json
{
  "dashboard_url": {
    ...
    "manifest": "---\nname: my-service-instance\n..."
  }
}
```

####<a id="dashboard-url-instance-id"></a>SERVICE-INSTANCE-ID

This parameter is the unique identifier of the service instance
provided by the Cloud Controller. For example, `42a09f38-c15b-47fe-a24e-ebf5f83ebd0`.

####<a id="dashboard-url-plan"></a>PLAN-JSON

This parameter is the current plan for the service instance as JSON.
The structure should be the same as the [plan given in the generate manifest](#plan).

See the following example:

```json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": [],
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```

####<a id="dashboard-url-manifest"></a>MANIFEST-YAML

This parameter is the current manifest as YAML.

The manifest format matches the BOSH v2 manifest. For more information about the
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in
the BOSH documentation.

See the following example:

```yaml
name: my-service-instance
releases:
- name: my-service
  version: 1.1.0
stemcells:
- alias: only-stemcell
  os: ubuntu-trusty
  version: "3468.1"
instance_groups:
- name: my-example-server
  instances: 1
  jobs:
  - name:  my-example-server
    release: my-service
  vm_type: t2.small
  stemcell: only-stemcell
  persistent_disk_type: 10GB
  azs:
  - z1
  networks:
  - name: default
  properties:
    some-parameter:
      param1: "some-value"
      param2: 1
update:
  canaries: 4
  canary_watch_time: 30000-240000
  update_watch_time: 30000-240000
  max_in_flight: 4
tags:
  product: my-product
addons:
- name: some-addon
  jobs:
  - name: my-example-server
    release: my-service
```

###<a id="dashboard-url-output"></a>Output

The following table describes the supported exit codes and output for the
`dashboard-url` subcommand:

| Exit code     | Description     | Output                                                                                                                                           |
|:--------------|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | <ul><li>Stdout: dashboard URL JSON</li></ul>                                                                                                     |
| 10            | not implemented |                                                                                                                                                  |
| anything else | failure         | <ul><li>Stdout: optional error message for CF CLI users</li><li>Stderr: error message for operator<br> ODB logs both stdout and stderr</li></ul> |

<br>
Example JSON output printed when the `dashboard-url` command is successful:

```
{
   "dashboard_url":"https://someurl.example.com"
}
```

<br>
The following table describes the output JSON above:

| Field         | Type   | Description                           |
|:--------------|:-------|:--------------------------------------|
| dashboard_url | string | Dashboard url returned to the cf user |

##<a id="create-binding"></a>create-binding

This section contains the following topics:

- [Input Parameters](#create-binding-parameters)
- [Output](#create-binding-output)

###<a id="create-binding-parameters"></a>Input Parameters

The following section details the parameters required by the `create-binding` subcommand as
a JSON document using stdin.

See the following example:

```json
{
  "create_binding": {
    "binding_id": "BINDING-ID",
    "bosh_vms": "BOSH-VMS-JSON",
    "manifest": "MANIFEST-YAML",
    "request_parameters": "REQUEST-PARAMETERS-JSON",
    "secrets": "MANIFEST-SECRETS-JSON",
    "dns_addresses": "DNS-ADDRESSES-JSON"
  }
}
```
<br>
All the arguments are passed as strings and not JSON objects.

For example:

```not-json
{
  "create_binding": {
    // ...
    "bosh_vms": "{\"mysql_node\": [\"192.0.2.1\", \"192.0.2.2\", \"192.0.2.3\"]}"
  }
}

```

####<a id="create-binding-id"></a>BINDING-ID

This parameter is the binding ID generated by the Cloud Controller.

####<a id="create-bosh-vms-json"></a>BOSH-VMS-JSON

This parameter is a JSON map of instance group name to an array of IP addresses
provisioned for that instance group.

See the following example:

```json
{
  "mysql_node": ["192.0.2.1", "192.0.2.2", "192.0.2.3"],
  "management_box": ["192.0.2.4"]
}
```

<br>
This can be used to connect to the instance deployment, if required, or to create a service specific binding.
In the example above, the Service Adapter may connect to MySQL as the admin and create a user.
As part of the binding, the `mysql_node` IP addresses would be returned, but  not the `management_box`.

####<a id="create-binding-manifest"></a>MANIFEST-YAML

This parameter is the current manifest as YAML.
This is used to extract information about the deployment that is necessary for the binding, such as admin credentials with which to create users.

The manifest format matches the BOSH v2 manifest. For more information about the
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in
the BOSH documentation.

####<a id="create-request-params-JSON"></a>REQUEST-PARAMS-JSON

This parameter is a JSON object that holds the entire body of the [service
binding](http://docs.cloudfoundry.org/services/api.html#binding) request sent
by the Cloud Controller to the service broker.

The field `bind_resource` contains key-value pairs for `app_guid`,
`credential_client_id` and `route`.  If using the <a href="#sdk">golang
SDK</a>, the `brokerapi.BindResource` struct containing these fields can be
accessed using the `BindResource()` helper method on requestParams.

The field `parameters` contains arbitrary key-value pairs which were passed by
the app developer as a `cf` CLI parameter when creating, or updating
the service instance.
If using the <a href="#sdk">golang SDK</a>, it can be
obtained using the `ArbitraryParams()` helper method on requestParams.

See the following example:

```json
{
  "app_guid": "app-guid-here",
  "bind_resource": {
    "app_guid": "app-guid-here"
  },
  "context": {
    "platform": "cloudfoundry",
    "some_param": "some-value"
  },
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "my-plan",
  "service_id": "my-service"
  }
  ```

####<a id="create-binding-secrets"></a>MANIFEST-SECRETS-JSON

If `enable_secure_manifests` is set to `true` in the broker,
any secrets in the service instance manifest that use references to BOSH-generated
variables or literal CredHub paths are resolved and sent to the adapter in the `MANIFEST-SECRETS-JSON` parameter.

If `enable_secure_manifests` is set to `false` in the broker,
then the `MANIFEST-SECRETS-JSON` parameter is empty.

The following is an example service instance manifest:

```
...
password: ((redis_password))
root_ca: ((/global/root_ca))

variables:
- name: redis_password
  type: password
```
<br>
The service instance manifest snippet above produces a secrets JSON parameter
similar to the following.
The keys are the reference names, and the values are the resolved secrets:

```
{
  "((redis_password))": "some-bosh-generated-password",
  "((/global/root_ca))": "some-global-value"
}
```

<p class="note"><strong>Note</strong>: You can find the secrets key by accessing
the manifest field that contains the reference to the variable.</p>

####<a id="create-binding-dns-addresses"></a>DNS-ADDRESSES-JSON

When this feature is enabled and a broker is deployed with `binding_with_dns` set for a plan,
the ODB retrieves DNS addresses from BOSH before calling the adapter.
ODB passes these addresses to the service adapter along with the names given in the
`binding_with_dns` properties.

For how to enable this feature for your on-demand service, see [Enable
BOSH DNS Addresses for Bindings](./service-adapter.html#dns-addresses).

The following is an example `binding_with_dns` configuration in the broker manifest:

```yaml
plans:
  ...
  - name: example-plan
    binding_with_dns:
    - name: leader-address
      link_provider: example-link-1
      instance_group: leader-node
    - name: follower-address
      link_provider: example-link-2
      instance_group: follower-node
```

<br>
The snippet above produces the following in `DNS-ADDRESSES-JSON`:

```json
{
  "leader-address": "q-s0.leader-node.default.service-instance_c1371314-643f-48b7-b80a-6741e7377022.bosh",
  "follower-address": "q-s0.follower-node.default.service-instance_c1371314-643f-48b7-b80a-6741e7377022.bosh"
}
```

<br>
Each entry in `binding_with_dns` is converted to a single BOSH DNS address using the BOSH links API.

The On Demand Services SDK includes the `DNSAddresses` parameter for the `CreateBinding` and `DeleteBinding` methods.
The ODB invokes the `CreateBinding` and `DeleteBinding` methods with this parameter, which is a map of name to DNS address.

###<a id="create-binding-output"></a>Output

The following table describes the supported exit codes and output for the
`create-binding` subcommand:

| Exit code     | Description                                       | Output                                                                                                                                               |
|:--------------|:--------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                                           | <ul><li>Stdout: binding credentials JSON </li></ul>                                                                                                  |
| 10            | subcommand not implemented                        |                                                                                                                                                      |
| 42            | app_guid not provided in the binding request body | <ul><li>Stderr: error message for operator</li><li>ODB logs both stdout and stderr </li></ul>                                                        |
| 49            | binding already exists                            | <ul><li>Stderr: error message for operator</li><li>ODB logs both stdout and stderr </li></ul>                                                        |
| anything else | failure                                           | <ul><li>Stdout: optional error message for CF CLI users</li><li>Stderr: error message for operator</li><li>ODB logs both stdout and stderr</li></ul> |

<br>
Example JSON output printed when the `create-binding` command is successful:

```json
{
  "credentials": {
    "username": "user1",
    "password": "reallysecret"
  },
  "syslog_drain_url": "optional: for syslog drain services only",
  "route_service_url": "optional: for route services only"
}
```

##<a id="delete-binding"></a>delete-binding

This subcommand should invalidate the credentials that were generated by
`create-binding` if possible.  For example, the subcommand would
delete the binding user in MySQL.

This section contains the following topics:

- [Input Parameters](#delete-binding-parameters)
- [Output](#delete-binding-output)

###<a id="delete-binding-parameters"></a>Input Parameters

This section describes the parameters required by the `delete-binding` subcommand.

See the following example:

```json
{
  "delete_binding": {
    "binding_id": "BINDING-ID",
    "bosh_vms": "BOSH-VMS-JSON",
    "manifest": "MANIFEST-YAML",
    "delete_parameters": "DELETE-PARAMETERS-JSON",
    "secrets": "MANIFEST-SECRETS-JSON",
    "dns_addresses": "DNS-ADDRESSES-JSON"
  }
}
```

<br>
All the arguments are passed as strings and not JSON objects.

For example:

```not-json
{
  "delete_binding": {
    // ...
    "manifest": "---\nname: some-name\n..."
  }
}

```

####<a id="delete-binding-id"></a>BINDING-ID

This parameter is the binding to be deleted.

####<a id="delete-binding-vm-json"></a>BOSH-VMS-JSON

This parameter is a map of instance group name to an array of IPs provisioned for that instance group.

See the following example:

```json
{
  "my-instance-group": ["192.0.2.1", "192.0.2.2", "192.0.2.3"]
}
```

####<a id="delete-binding-manifest"></a>MANIFEST-YAML

`MANIFEST-YAML` represents the parameter for the current manifest.
BOSH uses the manifest to extract information about the deployment
such as the credentials.

The manifest format matches the BOSH v2 manifest. For more information about the
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in
the BOSH documentation.

For an example, see the [Kafka delete binding](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/delete_binding.go).

####<a id="delete-params-JSON"></a>DELETE-PARAMS-JSON

This parameter is a JSON object that holds query string parameters as useful hints for service brokers. For more information, see the Open Service Broker API [documentation](http://docs.cloudfoundry.org/services/api.html#unbinding).

See the following example:

```json
{
  "plan_id":"my-plan-id",
  "service_id":"my-service-id"
}
```

<p class="note"><strong>Note</strong>: This parameter is different from the
  create-binding <code>request_parameters</code> parameter and, in particular,
  does not include <code>parameters</code> or <code>bind_resource</code>.</p>

####<a id="delete-binding-secrets"></a>MANIFEST-SECRETS-JSON

See [MANIFEST-SECRETS-JSON](#create-binding-secrets) above.

####<a id="delete-binding-dns-addresses"></a>DNS-ADDRESSES-JSON

See [DNS-ADDRESSES-JSON](#create-binding-dns-addresses) above.

###<a id="delete-binding-output"></a>Output

The following table describes the supported exit codes and output for the
`delete-binding` subcommand:

| exit code     | Description            | Output                                                                                                                                                |
|:--------------|:-----------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | <ul><li>No output is required </li></ul>                                                                                                              |
| 10            | not implemented        |                                                                                                                                                       |
| 41            | binding does not exist | <ul><li>Stderr: error message for operator</li><li>ODB logs both stdout and stderr </li></ul>                                                         |
| anything else | failure                | <ul><li>Stdout: optional error message for CF CLI users</li><li>Stderr: error message for operator</li><li>ODB logs both stdout and stderr </li></ul> |

<br>
This can be used to connect to the actual VMs if required, to delete a service specific binding.
For example, this can be used to delete a user in MySQL.


##<a id="generate-plan-schemas"></a>generate-plan-schemas

The broker uses the schema returned by this subcommand to validate service-specific
configuration parameters.
Apps Manager uses the schema to generate a form that users can use to populate
those parameters.
The schema must be in the JSON Schema draft-04 format.
For more information about the plan schema, see the [Open Service Broker API (OSBAPI) v2.13
specification](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#schema-object).

If you do not want to validate all parameters and want additional parameters to
be accepted without constraints, set the JSON schema field `additionalProperties` to `true`.
For the location of this field, see the [Kafka example
adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_plan_schemas.go#L43-L59).
For example, you might use this if you want to accept an
undocumented optional parameter, for administration purposes, that should not be
exposed through the Apps Manager UI.

This section contains the following topics:

- [Input Parameters](#generate-plan-schemas-parameters)
- [Output](#generate-plan-schemas-output)

###<a id="generate-plan-schemas-parameters"></a>Input Parameters

This section describes the parameters required by the `generate-plan-schemas`
subcommand, passed using stdin.

See the following example:

```json
{
  "generate_plan_schemas": {
    "plan": "PLAN-JSON"
  }
}
```

<br>
All the arguments are passed as strings and not JSON objects.

For example:

```not-json
{
  "generate_plan_schemas": {
    "plan": "{\"instance_groups\":[]}"
  }
}

```

####<a id="plan-json"></a>PLAN-JSON

This parameter is the service plan as JSON required to generate the JSON schema.

See the following example:

```json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": [],
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```

###<a id="generate-plan-schemas-output"></a>Output

The following table describes the supported exit codes and output for the
`generate-plan-schemas` subcommand:

| exit code     | Description            | Output                                                                                                                           |
|:--------------|:-----------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | <ul><li>Stdout: JSON document containing the plan schemas</li></ul>
| 10            | not implemented        |                                                  |
| anything else | failure                | <ul><li>Stdout: optional error message for cf CLI users</li> <li>Stderr: error message for operator</li>  <li>ODB logs both stdout and stderr</li></ul> |

<br>
Example JSON output printed when the `generate-plan-schemas` command is successful:

```json
{
  "service_instance": {
    "create": {
      "parameters": {
        "": "http://json-schema.org/draft-04/schema#",
        "additionalProperties": true,
        "properties": {
          "auto_create_topics": {
            "description": "Auto create topics",
            "type": "boolean"
          },
          "default_replication_factor": {
            "description": "Replication factor",
            "type": "integer"
          }
        },
        "type": "object"
      }
    },
    "update": {
      "parameters": {
        "": "http://json-schema.org/draft-04/schema#",
        "additionalProperties": true,
        "properties": {
          "auto_create_topics": {
            "description": "Auto create topics",
            "type": "boolean"
          },
          "default_replication_factor": {
            "description": "Replication factor",
            "type": "integer"
          }
        },
        "type": "object"
      }
    }
  },
  "service_binding": {
    "create": {
      "parameters": {
        "": "http://json-schema.org/draft-04/schema#",
        "additionalProperties": false,
        "properties": {
          "topic": {
            "description": "The name of the topic",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  }
}
```
